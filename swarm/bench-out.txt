Benchmark results with applied modifications. Numbers are now more reasonable since both
implementations need to do the initial protocol cloning.

|behaviours|iters|protocols per behaviour|-|time-per-iter|-|-|relation to optimized version|-|verdict|
|-|-----|--|---------|---------|---------|--------|--------|---------|--------------------------|
|1|10000|10|7.6035 ns|7.7618 ns|7.9634 ns|+46.884%|+101.01%|+188.79% |Performance has regressed.|
|1|10000|100|17.956 µs|19.036 µs|20.382 µs|+189586%|+312058%|+514568% |Performance has regressed.|
|1|10000|1000|1.5639 s|1.6051 s|1.6499 s|+7414.9%|+7652.0%|+7905.9% |Performance has regressed.|
|5|10000|2|9.0094 ns|9.2876 ns|9.5575 ns|+3.7805%|+48.109%|+110.34% |Performance has regressed.|
|5|10000|20|57.170 µs|61.703 µs|67.540 µs|+172759%|+313410%|+554174% |Performance has regressed.|
|5|10000|200|1.7835 s|1.8163 s|1.8515 s|+111.89%|+117.60%|+123.46% |Performance has regressed.|
|10|10000|1|12.783 ns|13.132 ns|13.534 ns|-23.336%|+22.887%|+90.767%|No change in performance detected.|
|10|10000|10|28.961 µs|31.101 µs|33.781 µs|+549.87%|+1095.6%|+2066.8% |Performance has regressed.|
|10|10000|100|1.8011 s|1.8359 s|1.8729 s|+47.806%|+51.715%|+56.117% |Performance has regressed.|
|20|5000|1|15.085 ns|15.527 ns|16.108 ns|-40.576%|-7.7926%|+42.042%|No change in performance detected.|
|20|5000|10|470.49 µs|507.08 µs|553.35 µs|+93.120%|+249.05%|+540.40% |Performance has regressed.|
|20|5000|100|1.9931 s|2.0245 s|2.0578 s|+9.9884%|+12.365%|+14.826% |Performance has regressed.|

Earlier I noticed that using network behaviour
macro degrades performace eventhough we do same amount of work based on parameters, [here]() my attemplt
to fix that. (TLDR is that current macro implementation creates somewhat of a linked list out of
types with two generics, I rewritten the macro to generate specialized type for each component of
the behaviour composition and also added some oprimizations, benchmark included).

